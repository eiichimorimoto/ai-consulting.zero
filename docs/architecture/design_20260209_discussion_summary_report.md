# 設計: 「何々に関する議論だけをまとめてレポートに」の流れ

**日付**: 2026-02-09  
**目的**: ユーザーが「AI回答とユーザーが議論した中で、〇〇に関する議論だけをまとめて整理してレポートにしてほしい」と依頼した場合の処理を整理し、方法を検討する。

---

## 1. 想定するユーザー発言の例

- 「先ほどの単価の話だけ、まとめてレポートにしてください」
- 「売上に関する議論を整理してレポートにしてほしい」
- 「コスト削減の議論だけ要約して資料にまとめて」
- 「これまでの〇〇についてのやり取りをレポート形式で出して」

いずれも「**あるテーマ（何々）についての会話を遡り、その部分だけを収集 → 整理・要約 → レポートとして出力**」というリクエスト。

---

## 2. 全体の流れ（案）

```
[ユーザー発言] 「単価の話だけまとめてレポートに」
        ↓
[① 依頼の種別判定] 「議論のまとめ＋レポート」系かどうか
        ↓
[② 復唱] 「単価に関する議論をまとめてレポートにする、という事ですね。よろしければ『はい』で。」
        ↓
[ユーザーが「はい」等]
        ↓
[③ テーマ（何々）の抽出] 「単価」「売上」「コスト削減」など
        ↓
[④ 会話を遡り該当議論を収集] セッションの consulting_messages から、テーマに関連する発言を選ぶ
        ↓
[⑤ 収集した会話をDifyに投げる] 「以下の会話を整理・要約し、レポート形式で出力してください」
        ↓
[Difyが要約レポートを返す]
        ↓
[⑥ 以降は既存のレポート作成と同じ] この1件を「レポート用」として記録 → エクスポートでPDF/PPT等
```

---

## 3. ステップごとの検討

### 3.1 ① 依頼の種別判定（「議論をまとめてレポート」）

**やること**: そのメッセージが「あるテーマの議論をまとめてレポートにしたい」系かどうかを判定する。

**方法案**:

- **キーワード／正規表現**  
  - 例: 「〇〇の話だけ」「〇〇に関する議論」「まとめてレポート」「議論を整理して」「要約してレポート」「やり取りをレポートに」  
  - `lib/consulting/report-request.ts` に `isDiscussionSummaryReportRequest(message): boolean` を追加し、既存の `isReportRequest` と同様にパターンで判定。
- **既存のレポート依頼との区別**  
  - 「レポートを作成して」だけ → これまでどおり「新規にDifyに問い合わせてレポート作成」。  
  - 「〇〇の議論をまとめてレポートに」→ 本フロー（会話収集 → Difyで要約 → レポート）。

**判定結果の使い分け**:

- `isDiscussionSummaryReportRequest(message) === true`  
  → 復唱の文言を「〇〇に関する議論をまとめてレポートにする、という事ですね。」にし、確認後に「会話収集 → Dify要約」に進む。  
- 従来の `isReportRequest(message)` のみ  
  → 従来どおり「その1クエリをDifyに投げてレポート」のまま。

---

### 3.2 ② 復唱

- 文言例: 「【テーマ】に関する議論をまとめてレポートにする、という事ですね。よろしければ『はい』や『お願いします』と送信してください。」
- テーマが取れない場合は「これまでの議論のうち、ご指定のテーマについてまとめてレポートにする、という事ですね。」など汎用文。
- ここまで**Difyは呼ばない**。保留クエリとして「元メッセージ」を保持（既存の `pending_report_query` または「議論まとめ用」用の別フィールド）。

---

### 3.3 ③ テーマ（何々）の抽出

**入力**: ユーザーの元メッセージ（例: 「単価の話だけまとめてレポートに」）。

**出力**: レポート対象のテーマを表す文字列（例: 「単価」「単価低下」「売上」「コスト削減」）。

**方法案**:

| 案 | 内容 | メリット | デメリット |
|----|------|----------|------------|
| A. 正規表現・キーワード | 「〇〇の話」「〇〇に関する」「〇〇について」の「〇〇」部分をキャプチャ。よく出る語（単価・売上・コスト・施策など）を辞書で補強。 | 実装が軽い。LLM不要。 | 言い回しが変わると取りこぼす。 |
| B. 小さいLLM／API | 1文を渡して「この文でレポートにまとめたいテーマを短いキーワードで抽出」 | 言い回しの揺れに強い。 | コスト・レイテンシ。 |
| C. ハイブリッド | まず正規表現で取り、取れなければ「議論」「話」「やり取り」の前の名詞句をフォールバックで使う。 | 多くのケースでAで足りつつ、少しだけ範囲を広げられる。 | ルールが少し複雑。 |

**推奨**: まず **A または C** で実装し、取りこぼしが多ければ B を検討。

---

### 3.4 ④ 会話を遡り該当議論を収集

**入力**:

- セッションID
- テーマ（③で抽出した文字列）

**データ**: `consulting_messages` を `session_id` で取得し、`message_order` または `created_at` で時系列に並べる。

**「何々に関する議論」の収集方法案**:

| 案 | 内容 | メリット | デメリット |
|----|------|----------|------------|
| A. キーワード一致 | 各メッセージの `content` にテーマ（またはその部分文字列）が含まれるものを収集。 | 実装が簡単。高速。 | 言及なしで文脈上だけ関連する発言は含まれない。 |
| B. 直近N件＋テーマ | 直近N件（例: 20件）を取得し、その中でテーマに言及しているものだけ残す。または直近N件をまとめてDifyに渡す。 | 「直近の議論」をまとめる用途に合う。 | 古いが重要な議論は落ちる可能性。 |
| C. 全件＋関連度フィルタ | セッションの会話を全件取り、テーマキーワードを含むものを優先して採用（またはDifyに「関連する部分だけ」選ばせる）。 | 漏れが少ない。 | 件数が多くなるとトークン・コストが増える。 |
| D. Difyに選ばせる | 会話全文（または要約）とテーマをDifyに渡し、「このテーマに関連する発言だけを抜き出して」と依頼。その結果を次の要約に渡す。 | 文脈で「関連」を判断できる。 | 2回Difyを呼ぶ形になり、コスト・時間がかかる。 |

**推奨**:  
- まず **A（テーマキーワードを含む発言を収集）** で実装。  
- 必要なら「直近K件に限定」「最低M件は必ず含める」などの条件を追加（Bに近づける）。  
- 収集件数が多すぎる場合は、古い方を間引くか、要約してからDifyに渡す。

**出力**: 収集したメッセージの配列（例: `{ role, content, created_at }[]`）。これを1つのテキストに整形して次のステップへ。

---

### 3.5 ⑤ 収集した会話をDifyに投げて整理・要約

**やること**: ④で作った「会話テキスト」と、依頼内容をDifyに送り、「整理・要約しレポート形式で出力」してもらう。

**方法案**:

| 案 | 内容 | メリット | デメリット |
|----|------|----------|------------|
| A. 既存Chat APIに長文で渡す | `query` に「以下の会話を【テーマ】について整理・要約し、レポート形式（見出し・箇条書き）で出力してください。」と書き、その直後に会話全文を貼る。 | 既存の `/api/dify/chat` をそのまま使える。 | 会話が長いとトークン上限やノイズの可能性。 |
| B. 要約専用ワークフロー | Dify側に「会話＋テーマ」を入力とする要約用ワークフローを作り、そこだけ呼ぶ。 | プロンプトを要約用に最適化できる。 | Difyの変更が必要。 |
| C. 会話を事前要約してからDify | 会話が長い場合、別のLLMやルールで一旦要約してからDifyに渡す。 | トークン節約。 | 実装とコストが増える。 |

**推奨**: まず **A（既存Chat APIに prompt＋会話テキスト を query として渡す）**。会話が極端に長い場合だけ、件数制限やトリミング（直近N件など）を入れる。

**Difyへの入力イメージ**:

- `query`: 「以下は、ある相談セッションの会話です。【単価】に関する部分を整理・要約し、レポート形式（見出し・箇条書き・必要なら表）で出力してください。\n\n---\n\n[ここに会話テキスト]」

**Difyの返答**: 要約レポート本文。これを「レポート用1件」として保存する。

---

### 3.6 ⑥ 以降は既存のレポート作成と同じ

- Difyの返答を **1件のAIメッセージ** として保存する際に、「レポート用」フラグを付ける（既存のレポートサイン／レポート用フラグと同じ考え方）。
- エクスポートでは「レポート用」としてマークされたメッセージだけを「AIの回答」に列挙し、PDF/PPT/Markdown に含める。
- ユーザーが「レポートをエクスポート」したら、この1件がレポートの本体（または1セクション）になる。

---

## 4. 既存フローとの統合

| 項目 | 既存（新規レポート依頼） | 本フロー（議論まとめレポート） |
|------|--------------------------|----------------------------------|
| トリガー | 「レポートを作成して」等 | 「〇〇の議論をまとめてレポートに」等 |
| 復唱 | 「〇〇のレポートをお作りしますね」 | 「〇〇に関する議論をまとめてレポートにする、という事ですね」 |
| 確認後 | 元メッセージをそのままDifyに送る | テーマ抽出 → 会話収集 → 会話テキスト＋依頼文をDifyに送る |
| Difyの役割 | 1クエリでレポート内容を生成 | 渡された会話を整理・要約してレポート形式で返す |
| レポート用フラグ | その1回のDify回答に付与 | 同様に、この1回のDify回答に付与 |

**APIの分岐イメージ**（POST messages 内）:

1. `isConfirmation(message)` かつ `pending_report_query` あり  
   → さらに `isDiscussionSummaryReportRequest(pending_report_query)` かどうかで分岐。  
   - **true**: テーマ抽出 → 会話取得・収集 → Difyに会話＋要約依頼を送信 → 返答をレポート用として保存。  
   - **false**: 従来どおり `pending_report_query` をそのままDifyに送信 → 返答をレポート用として保存。
2. 復唱を出す段階では、`isReportRequest(message)` に加え `isDiscussionSummaryReportRequest(message)` も見て、「議論まとめレポート」用の復唱文と保留クエリを設定する。

---

## 5. データ・APIの検討

- **保留クエリの区別**  
  - 現状は `pending_report_query` 1本。  
  - 「議論まとめ」か「新規レポート」かを区別するなら、`pending_report_type: 'report' | 'discussion_summary'` のようなフラグをセッションに持たせると分岐しやすい。
- **会話の取得**  
  - POST ハンドラ内で、そのセッションの `consulting_messages` を `select` し、`message_order` 昇順で取得。  
  - または既存の GET `/api/consulting/sessions/[id]/messages` のロジックを共通化して再利用。
- **トークン・長さ**  
  - 会話をそのままDifyに渡すと長くなりがちなので、件数上限（例: 直近50件）や文字数上限を設けると安全。超えた場合は古い方を削るか、要約してから渡す。

---

## 6. まとめ

- **判定**: 「何々に関する議論をまとめてレポートに」系を `isDiscussionSummaryReportRequest(message)` で検出。
- **復唱**: 「〇〇に関する議論をまとめてレポートにする、という事ですね。」で確認を取る。
- **確認後**: テーマ抽出 → 会話を遡って該当議論を収集（まずはキーワード一致）→ 会話テキスト＋要約依頼をDifyに送る → 返答をレポート用1件として保存。
- **以降**: 既存のレポート作成と同じ（レポート用フラグ → エクスポートでPDF/PPT等）。

この流れにすると、「議論の一部だけをまとめたレポート」と「新規に1クエリで作るレポート」の両方を、同じレポート作成・エクスポートの土台の上で扱える。

---

## 7. 提案まとめでの再利用（将来）

**背景**: 最終的に提案を纏めるときも、会話全件をなめて課題と対策を提示する処理が必要になる。

**方針**: 会話収集とDifyへの投入は共通モジュール化し、以下で再利用する。

- **会話収集**: `lib/consulting/conversation-collector.ts`
  - `collectMessagesByTheme(supabase, sessionId, theme, options)` … テーマでキーワード一致した発言を収集（議論まとめで使用）。
  - `getAllSessionMessages(supabase, sessionId, maxMessages)` … 全会話を取得。提案まとめで「会話全件をなめる」ときに利用する想定。
  - `formatCollectedConversation(messages)` … 収集結果を「【ユーザー】/【AI】」形式の1本テキストに整形。
- **利用イメージ（提案まとめ）**  
  1. ユーザーが「これまでの相談内容を踏まえて提案をまとめて」等と依頼。  
  2. `getAllSessionMessages` で会話全件取得（または件数上限付き）。  
  3. 会話テキスト＋「上記会話から課題と対策を整理し、提案書形式で出力してください」のようなプロンプトをDifyに送る。  
  4. 返答をレポート／提案用1件として保存し、既存のエクスポートに載せる。

議論まとめと提案まとめで、**会話の取得・整形**だけ共通化し、**依頼の種別ごとにプロンプト文を変える**形にすると拡張しやすい。

---

## 8. 実装メモ（A案ベース）

- **保留の種別**: DBカラムは増やさず、`pending_report_query` の先頭に `__DISCUSSION_SUMMARY__:` を付与して議論まとめ用と識別（`isPendingDiscussionSummary` / `unwrapPendingDiscussionSummaryQuery`）。
- **実装箇所**  
  - `lib/consulting/report-request.ts`: `isDiscussionSummaryReportRequest`, `extractDiscussionSummaryTheme`, `buildDiscussionSummaryEchoReply`, プレフィックス判定・unwrap。  
  - `lib/consulting/conversation-collector.ts`: 上記の会話収集・整形（再利用可能）。  
  - `app/api/consulting/sessions/[id]/messages/route.ts`: 復唱時の種別分岐、確認後の議論まとめ分岐（テーマ抽出 → 収集 → プロンプト組み立て → Dify → 返答保存）。
