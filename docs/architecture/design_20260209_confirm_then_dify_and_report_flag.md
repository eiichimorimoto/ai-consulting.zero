# プロセス整理: 確認→Dify→レポートサイン

**日付**: 2026-02-09  
**目的**: 「依頼された内容だけをレポートにする」ためのフローを整理する。  
**前提**: 会話全体は別で出力できるため、レポートに「AIの回答のすべて」を含める必要はない。レポートは「ユーザーがレポート・資料等を依頼したときの、その1回のDify回答」だけを対象にする。

---

## 0. 「レポート作成して」はどこで・どう判断するか（A案の実装）

### どこで判断するか

**場所**: `app/api/consulting/sessions/[id]/messages/route.ts` の **POST** ハンドラ内。

**タイミング**:
1. ユーザーメッセージをDBに保存した直後
2. Difyを呼ぶかどうかを決める直前

つまり「ユーザーが送信したそのメッセージ本文」を、APIが受け取った時点で1回だけ判定している。

### どう判断するか

**関数**: `lib/consulting/report-request.ts` の **`isReportRequest(message)`** を呼ぶ。

**中身**: メッセージ文字列が、あらかじめ定義した正規表現パターンの**どれか1つでもマッチ**すれば「レポート依頼」とみなす。

```ts
// 判定ロジック（report-request.ts）
const REPORT_REQUEST_PATTERNS = [
  /レポート\s*(を?\s*)?(作成|作って|出力|出して|ください|お願い)/i,
  /資料\s*(を?\s*)?(作成|作って|出力|出して|ください|お願い)/i,
  /(作成|作って|出力|出して)\s*(して\s*)?(ください|お願い)/i,
  /(まとめて|まとめ)\s*(レポート|資料|報告)/i,
  /(報告書|提案書)\s*(を?\s*)?(作成|作って|ください)/i,
  /PDF\s*(で\s*)?(出して|ください|お願い)/i,
  /(出して|ください|お願い)\s*((レポート|資料|報告書)|PDF)/i,
];
// メッセージが2文字以上 かつ 上記のいずれかにマッチ → true
```

**例**: 「レポート作成して」「単価のレポートをお願いします」「資料を出してください」→ いずれも `true`。  
「単価低下の原因を教えて」だけなら どのパターンにも当たらなければ `false`。

**復唱・確認時の実装上の注意（2026-02-09 追記）**:
- **復唱文**: ユーザー指示は「」で囲む。例: 「もう一度今の回答に関してレポートにして」のレポート（資料）をお作りしますね。よろしければ「はい」や「お願いします」と送信してください。
- **確認後にDifyを呼ぶとき**: `conversation_id` を渡さない。依頼文だけを送り、レポートを新規生成させる（会話履歴に引きずられず確実にレポートが返るようにする）。
- **エクスポート対象**: 復唱メッセージ（「〇〇のレポートをお作りしますね。よろしければ…」等）はレポートに値しないため、`isEchoReplyContent(content)` で除外し、エクスポート一覧に含めない。

**レポート対象の参照解決（会話遡及・2026-02-09 追記）**:
- レポート対象は「必ずしも直上のAI回答」ではない。「**何々の内容をレポートに**」「**先ほどの〇〇をレポートに**」等のときは、会話を遡って「何々」に該当するAI回答を特定する。
- **参照抽出**: `extractReportTargetReference(userMessage)` でユーザー発言から「何々」を取得。「これ」「この内容」「今の回答」のときは `null`（＝直上のAI回答を対象）。
- **会話遡及**: `findAssistantMessageByReference(assistantMessages, reference)` で、見出しまたは本文に参照が含まれるAIメッセージを探す。複数あれば直近の1件を採用。
- **復唱**: 特定した対象の見出しで「「〇〇」のレポート（資料）をお作りしますね。」と返し、**その対象の全文**を `pending_report_query` に保存。確認後はその全文を Dify に「以下をレポート形式で整えてください」と送り、Dify でレポート化する。

### 判定結果の使い方（A案の流れ）

| 条件 | やること |
|------|----------|
| `isReportRequest(message)` が **true** かつ、セッションに **pending_report_query がない** | 復唱を表示し、`pending_report_query = message` を保存。Difyは呼ばない。 |
| セッションに **pending_report_query がある** かつ `isConfirmation(message)` が **true** | 保留クエリをDifyに送る。応答を保存。`pending_report_query` をクリア。 |
| 上記以外 | 送信メッセージをそのままDifyに送る。 |

「レポート作成して」系の判断は**すべて**この `isReportRequest(message)` の結果で行っている。判定を変えたい場合は、`lib/consulting/report-request.ts` の `REPORT_REQUEST_PATTERNS` を増やす・変える。

---

## 1. 全体の流れ（目指す形）

```
[ユーザーがメッセージ送信]
        ↓
[Webアプリが内容を解釈]  ※Difyは呼ばない
        ↓
[復唱を表示] 「〇〇に関して〇〇する事ですね。」
        ↓
[ユーザーが確認] 「そうです」「OK」「はい」など
        ↓
[レポート依頼の有無を判定] 元メッセージに「レポート」「資料」「フォーム」作成の言及があれば「レポートサイン」を立てる
        ↓
[Difyに元メッセージを送信]
        ↓
[Difyが回答]
        ↓
[レポートサインが立っていれば]
  → この回答を「レポート用1件」として記録し、レポート作成フローへ
  → レポート作成処理後にレポートサインを消す
[立っていなければ]
  → 通常の会話として表示するだけ。レポートは作らない。
```

---

## 2. ステップごとの整理

### 2.1 すべてのユーザー発言を「いったん解釈して確認」

- **やること**: ユーザーの発言をDifyに渡す前に、Webアプリ側で「何を求めているか」を解釈する。
- **表示**: 解釈結果を復唱として表示する。  
  例: 「単価低下の原因を特定して、対策のレポートを作成してほしい、という事ですね。」
- **この時点ではDifyは呼ばない。** 元のユーザーメッセージは「保留クエリ」として保持する。

### 2.2 ユーザーが確認したときだけDifyに送る

- **確認とみなす返答**: 「そうです」「OKです」「はい」「お願いします」など。
- **やること**: 保留していた元メッセージをDifyに送信する。  
  （現在の `pending_report_query` の「確認後にDifyに送る」の考え方と同じ。）

### 2.3 レポートサインを立てる条件

- **タイミング**: 保留クエリをDifyに送る直前に判定する。
- **条件**: その**元メッセージ（保留クエリ）**の文言に、次のような「作成依頼」が含まれるかで判定する。
  - レポートを作成して / レポートを出して / レポートお願い
  - 資料を作成して / 資料を出して
  - フォームを作成して / フォームでまとめて
  - 報告書・提案書・PDF を出して など
- **やること**: 条件を満たすときだけ「レポートサイン」を立てる（セッションやリクエストにフラグを保持）。

### 2.4 Dify回答後の分岐

- **レポートサインが立っている場合**
  - このDify回答を「レポート用の1件」として扱う。
  - レポート作成フロー（PDF/PPT/Markdownなど）に渡す。
  - レポート作成処理が終わったら、**レポートサインを消す**。
- **レポートサインが立っていない場合**
  - 通常のAI返答として表示するだけ。
  - レポートは作らない。エクスポートの「AIの回答」一覧にも、この回答は「レポート用」としては含めない。

### 2.5 レポートに含めるもの（結果として）

- **含める**: ユーザーが「レポート／資料／フォームを作成して」と依頼し、確認→Dify→レポートサイン経由で作成した「その1回（またはその依頼に対応する回答）」だけ。
- **含めない**: 上記以外の通常のAI返答。会話ログは「会話全体」で出力すれば足りる。

---

## 3. 現状実装との対応

| 項目 | 現状 | この設計でやること |
|------|------|-------------------|
| 復唱 | レポート依頼と判定したときだけ復唱 | **すべての**ユーザー発言でいったん解釈し、復唱を表示する |
| 保留クエリ | `pending_report_query`（レポート依頼時のみ） | すべてのメッセージで「確認待ちクエリ」を保持する（名前は `pending_report_query` のままでも、用途を「確認待ちの元メッセージ」に広げる） |
| 確認後のDify | レポート依頼＋確認のときだけ保留クエリを送信 | **確認が返ってきたら常に**保留クエリをDifyに送る |
| レポートサイン | なし | 保留クエリに「レポート・資料・フォーム作成」の言及があるときだけフラグを立て、Dify応答後に参照 |
| レポート対象 | 会話中のAIメッセージをほぼすべて「AIの回答」として列挙 | レポートサインが立っていたときの**その1回のDify回答**だけをレポート用として扱う |
| サインを消す | — | レポート作成処理完了後にレポートサインを消す |

---

## 4. 用語の整理

| 用語 | 意味 |
|------|------|
| **復唱** | ユーザー発言を解釈した結果を、「〇〇に関して〇〇する事ですね。」のように返す表示。Difyは使わない。 |
| **保留クエリ** | 復唱に対応する元のユーザーメッセージ。確認が返ってくるまで保持し、確認後にDifyに送る。 |
| **レポートサイン** | 「このDify呼び出しの結果をレポートに使う」というフラグ。保留クエリにレポート・資料・フォーム作成の依頼が含まれるときに立て、レポート作成後に消す。 |
| **レポート用1件** | レポートサインが立った状態でDifyから返ってきた1件の回答。エクスポート時の「AIの回答」には、この種のものだけを含める。 |

---

## 5. 実装時の注意（データ・API）

- **確認待ちの一元化**: 今は「レポート依頼のときだけ」保留しているが、**すべてのメッセージ**で「復唱→確認→Dify」にするため、通常の相談メッセージもいったん保留し、確認後にDifyに送る形に変える。
- **解釈・復唱文の生成**: 復唱は「何々に関して何々する事ですね」の形にする。  
  - 軽量にやるなら: キーワードやテンプレートで要約。  
  - より自然にするなら: 小さいLLMやルールで要約してからテンプレに当てはめる。
- **レポートサインの持ち方**: セッションに `report_sign` のようなフラグを立て、Difyリクエスト時に「このリクエストはレポート用」と分かるようにする。Dify応答を保存するときに、そのフラグと紐付けて「レポート用1件」として記録する。
- **エクスポート時の「AIの回答」**: DBまたはフロントで「レポート用としてマークされたメッセージ」だけを列挙し、それだけをレポートに含める。会話中の他のAIメッセージは「会話全体」側に含め、レポートの「AIの回答」には含めない。

---

## 6. まとめ（プロセスの一文要約）

1. **全メッセージ**: 送信→解釈→復唱表示（Difyは呼ばない）。  
2. **確認時**: 保留クエリをDifyに送る。送る直前に「レポート・資料・フォーム作成」の言及があればレポートサインを立てる。  
3. **Dify応答後**: レポートサインがあればその1件だけレポート作成フローに渡し、作成後にサインを消す。なければ通常の会話として表示するだけ。  
4. **レポートに載せるAI回答**: レポートサインが立っていたときの、その1回のDify回答のみ。それ以外のAI発言はレポートには載せない（会話全体で見れば足りる）。

このプロセスに沿って実装すれば、「依頼された内容だけでレポートを作る」形になる。

---

## 7. 代替案（確認ステップを減らす）

「毎回 復唱→確認」は手間になる可能性があるため、以下の代替を検討できる。

### 案A: レポート依頼のときだけ確認（現状に近い・おすすめ）

- **通常のメッセージ**: そのままDifyに送る（確認なし）。
- **「レポート／資料を作成して」と検出したときだけ**: 復唱→「はい」で確認→Difyに送る。このときだけレポートサインを立て、その1回のDify回答だけを「レポート用」として記録する。
- **メリット**: 確認が増えるのは「レポートが欲しいとき」だけ。普段の会話はスムーズ。実装変更も少ない。
- **デメリット**: 「すべての問いをいったん解釈」はしない。

### 案B: エクスポート時にユーザーが選ぶ（いちばんシンプル）

- 会話は現状どおり（すべてDifyに送る）。復唱・レポートサインは使わない。
- レポートエクスポート画面で「どのAI回答をレポートに含めるか」をユーザーがチェックで選択する（現状のExportDialogの「AIの回答」リストをそのまま活用）。
- 「レポート用」の自動判定はしない。**ユーザーが選んだものだけ**がレポートに含まれる。
- **メリット**: 実装がほぼそのまま。確認フロー不要。ユーザーが最終的に何をレポートに載せるか完全にコントロールできる。
- **デメリット**: エクスポートのたびに選択する手間は残る（ただし「会話全体」と「自分で選んだAI回答」で済む）。

### 案C: Dify側で「レポート出力するか」を返す

- すべてのメッセージをDifyに送る（現状どおり）。
- Difyのワークフロー側で「この回答をレポートとして出力するか」を判定し、メタデータ（例: `output_as_report: true`）で返す。
- Webアプリはそのフラグを見て、true のときだけそのメッセージを「レポート用1件」として記録する。
- **メリット**: ユーザーに確認ステップを増やさない。解釈をDifyに任せられる。
- **デメリット**: Dify側のワークフロー・プロンプトの変更が必要。

### 案D: ハイブリッド（案A + レポート用マークの明示）

- 案Aと同じく「レポート依頼のときだけ」復唱→確認→Dify。
- そのときのDify回答に「レポート用」フラグを付けて保存する。エクスポートの「AIの回答」一覧には、**このフラグが付いたメッセージだけ**を表示する（現状の「会話中のAIメッセージをすべて列挙」はやめる）。
- **メリット**: 確認が増えるのはレポートが欲しいときだけ。レポートに載るのは「依頼された1回」に限定できる。案Aの具体的な形。

---

## 8. 推奨

- **手間を減らしたい**: **案A または 案D**（レポート依頼時だけ復唱＋レポートサイン／レポート用フラグ）。普段の会話はそのままDifyで、レポート対象は「その1回」に限定できる。
- **実装を変えたくない**: **案B**（エクスポート時にユーザーが選ぶ）。現状のUIを活かしつつ、「全部入り」にしないだけなら、選択肢を減らす表示やデフォルトの付け方で調整できる。
- **Difyをいじれる**: **案C**も選択肢。判定をDifyに寄せると、Webアプリの復唱ロジックは不要になる。

---

## 9. 関連: 「何々に関する議論だけをまとめてレポートに」

「〇〇の議論だけまとめてレポートにして」のように、**会話を遡って該当テーマの議論を収集し、Difyで整理・要約してレポートにする**フローは、別ドキュメントで整理している。

- **設計**: `docs/architecture/design_20260209_discussion_summary_report.md`
- **流れ**: 依頼判定 → 復唱 → 確認 → テーマ抽出 → 会話収集（キーワード一致等）→ Difyに会話＋要約依頼 → 返答をレポート用1件として保存 → 既存のエクスポートと同じ。
