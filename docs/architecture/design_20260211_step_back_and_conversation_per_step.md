# 設計: ステップを戻る対応と STEP 毎の会話管理

## 1. 現状と課題

### 1.1 ステップを戻る
- 左メニューで**完了したステップ**をクリックすると「STEP N に戻ると、現在の進捗が変更されます。よろしいですか？」と確認が出る。
- **戻る**を押すと `confirmStepNavigation()` が呼ばれるが、**ローカル state の `currentStepId` を変えているだけ**で、以下が未対応。
  - **API で `current_round` を更新していない** → リロードで元の進捗に戻る。
  - **どのメッセージがどの STEP の会話か**が DB にないため、「その STEP の会話」を判定・表示できない。
  - ステップ終了時のレポートも「その STEP の会話」を切り出せない。

### 1.2 会話の持ち方
- 現状は**1 セッション = 1 会話**で、STEP の区切りがない。
- STEP 5 まで同じ会話で持つとメッセージ数が多くなり、表示・レポート・Dify コンテキストが重くなる。
- 「STEP が進んだらチャットを初期状態にするか」「そのまま積み重ねるか」の整理が必要。

---

## 2. 要件の整理

| 項目 | 内容 |
|------|------|
| ステップを戻る | 完了した STEP を押して「戻る」で、**その STEP にいる状態**に戻す。サーバー側（`current_round`）も更新し、表示は「その STEP の会話」に合わせる。 |
| **戻っても他 STEP は維持** | 戻る = 表示と新規メッセージの所属を変えるだけ。**他 STEP（例: 現状分析）の会話はやり直しにせず、続きとして保持する**。フラグ（`current_round` / `step_round`）で制御。 |
| 会話の所属 | **どのメッセージがどの STEP の会話か**を一意に判定できるようにする（DB に `step_round` が必要）。 |
| ステップ終了の判定 | ステップ終了時レポートは「その STEP でやり取りした会話だけ」を使って作成する。 |
| チャット表示 | **その STEP の会話だけ表示**する方針（STEP が進んだら次の STEP 用の会話として表示を切り替え）。 |
| データ量 | STEP ごとに会話を分けて管理。**全部 Supabase に持つ設計でよい**；表示は STEP 単位に絞る。重くなったらページネーション・要約・アーカイブを検討（§8）。 |

---

## 3. 方針: Supabase に `step_round` を追加し、STEP 毎に会話を切る

### 3.1 メッセージに STEP を付与（Supabase）

- **`consulting_messages` に `step_round` を追加**（1〜5、既存は 1 などでマイグレーション）。
- メッセージ保存時は「**現在の STEP**」を `step_round` にセットする。
  - 現在 STEP = `current_round + 1`（1 始まり）とすれば、`step_round = current_round + 1` でよい。

これで「その STEP の会話か」を常に判定できる。

### 3.2 ステップを戻るのサーバー対応

- **戻る = その STEP に再度いる状態にすること**とし、サーバーで `current_round` を更新する。
- **他 STEP のメッセージは削除・上書きしない**。戻る操作で変えるのは「今どこの STEP にいるか」（`current_round`）だけ。既存メッセージの `step_round` は変更しない（詳細は §7）。
- 例: STEP 2 に戻る → `current_round = 1` にする API を用意する。
  - 既存の `PATCH /api/consulting/sessions/[id]` で `current_round` を渡して更新するか、  
    `POST /api/consulting/sessions/[id]/set-step` のように「表示 STEP を指定する」専用 API を用意する。
- クライアントは「戻る」確定時にこの API を呼び、成功したらローカルも `currentStepId` を合わせ、**その STEP のメッセージだけ**を表示する（下記 3.3）。

### 3.3 チャット表示: STEP 毎（その STEP の会話だけ表示）

- **STEP が進んだら、チャットは「今いる STEP の会話だけ」表示する**方針を推奨。
  - 戻ったときは「戻った先の STEP の会話だけ」表示。
- 実装イメージ:
  - **GET /api/consulting/sessions/[id]/messages** に `step_round` を渡す（または `current_round` から算出）。
  - 返すメッセージを **`step_round = 指定 STEP` のものだけ**に絞る。
  - フロントは「現在の STEP」を 1 つ持っておき、メッセージ取得・送信はその STEP で行う。
- 効果:
  - 1 セッションで 5 本の会話として扱え、表示・レポート・将来の Dify の「STEP 単位コンテキスト」と揃う。
  - 「STEP 毎に会話を管理する」という要望に沿う。

### 3.4 ステップ終了時レポート

- ステップ終了時は、**終了した STEP の `step_round` に一致するメッセージだけ**を取得してレポート生成に使う（既存の Phase 4 設計と同じ考え方）。

### 3.5 Dify の会話 ID（将来の拡張）

- 現状は 1 セッション 1 `conversation_id` でよい。
- のちに「STEP ごとに Dify の会話を分けたい」場合は、  
  `consulting_sessions` に `conversation_ids`（JSONB で step_round → conversation_id）を追加する、などの拡張で対応可能。まずは `step_round` と表示の切り替えまでを実装する。

---

## 4. 実装の順序（案）

1. **DB**: `consulting_messages.step_round` 追加（マイグレーション + 型）。
2. **API**: メッセージ保存時に `step_round` をセット（現在 STEP = `current_round + 1`）。
3. **API**: 「ステップを戻る」用に `current_round` を指定して更新する API（PATCH または POST set-step）。
4. **API**: GET messages で `step_round` でフィルタする（クエリで `step_round = 指定値`、指定がなければ従来どおり全件でも可）。
5. **フロント**: 「戻る」確定時に上記 API を呼び、成功後に `currentStepId` を更新し、**その STEP のメッセージだけ**を再取得して表示。
6. **フロント**: メッセージ一覧取得時に「現在 STEP」を渡し、STEP 毎の表示に切り替え。
7. （Phase 4）ステップ終了時レポートは、該当 `step_round` のメッセージだけを集めて生成。

---

## 5. まとめ

| やること | 内容 |
|----------|------|
| Supabase | `consulting_messages` に `step_round` を追加。 |
| ステップを戻る | 確認後に API で `current_round` を更新し、表示はその STEP の会話だけにする。**他 STEP のメッセージは触らない（続きとして維持）**（§7）。 |
| 会話の所属判定 | すべて `step_round` で行う。ステップ終了レポートも同じ。 |
| チャット表示 | STEP 毎に「その STEP の会話だけ」表示する形にし、STEP が進んだら「次の STEP 用」の会話として表示を切り替える。 |
| データ量 | ステップ毎の会話は**全部 Supabase に持つ**。表示は STEP 単位に絞るので重くなりにくい；必要ならページネーション・要約・アーカイブで対処（§8）。 |

この方針で進めれば、「ステップを戻る」の対応と「STEP 毎の会話管理」の両方を満たせます。実装は上記の順で、既存の実装計画（Phase 3 の step_round 追加など）と統合して進めるのがよいです。

---

## 6. STEP を遡る方法: 明示的戻る vs 内容で自動フラグ（次に進んだときだけ）

### 6.1 二つの考え方

| 方式 | 説明 | メリット | デメリット |
|------|------|----------|------------|
| **A. わざわざステップを戻す** | ユーザーが左メニューで完了した STEP を押し、「戻る」で確定。API で `current_round` を戻し、表示をその STEP の会話に切り替える。 | 意図が明確で実装が単純。どの STEP にいるか確実。 | 戻りたいときにいちいち操作が必要。 |
| **B. 内容から判断してフラグを付ける（次に進んだときだけ）** | すでに STEP 2 などに進んだあと、ユーザーの発言が「STEP 1（課題ヒアリング）の内容」と AI が判断したら、そのメッセージ（と続くやり取り）に `step_round=1` を付ける。戻る操作は使わない。 | 会話の流れのまま遡れる。戻るボタンを探さなくてよい。 | 判定の精度・ルール設計が必要。誤判定の扱い。 |

### 6.2 推奨: 両方使う（ハイブリッド）

- **基本**: 「ステップを戻る」は**明示的戻る（A）**で実装する。  
  → 戻りたいときは左メニューで STEP を選び、確認で戻す。確実で分かりやすい。
- **補助（任意・後から）**: **次に進んだあとだけ**、発言内容から「どの STEP の話題か」を判定し、`step_round` を付ける（B）。  
  - 例: いま STEP 2 にいるが「課題についてもう一点だけ追加で」と書いた → そのメッセージ（とその返答）を `step_round=1` として保存。  
  - レポートでは「STEP 1 の会話」に含められる。  
  - 表示は「明示的に戻ったときはその STEP の会話だけ表示」、内容ベースのフラグは「どの STEP のレポートに含めるか」の判定に使う、などと役割を分けられる。
- **運用**: まずは **A だけ**でリリースし、必要なら B（内容判定で `step_round` を付ける）を Dify の返答やバッチで後付けする形にすると、実装が軽い。

### 6.3 まとめ

- **「わざわざステップを戻す」**: そのまま採用する。戻る操作と API で `current_round` を更新し、表示をその STEP に合わせる。
- **「内容から判断してフラグを付ける」**: **次に進んだときだけ**を対象にし、任意拡張として「発言がどの STEP の話題か」を AI 判定して `step_round` を付ける。まずは A を実装し、必要に応じて B を足す形が扱いやすい。

---

## 7. ステップを戻したときの意味：続きであってやり直しではない（フラグ制御）

### 7.1 想定シナリオ

- ユーザーは STEP 2（現状分析）を進めている。
- その過程で**新しい課題**が出てきたので、STEP 1（課題のヒアリング）に戻って追記したい。
- **戻る = STEP 1 の会話に「続き」で足す**ことであり、**STEP 2 をやり直す・消すことではない**。
- したがって **STEP 2 は維持**し、あとで STEP 2 に再び進んだときは**現状分析の続き**として同じ会話が残っている必要がある。

### 7.2 フラグ制御の方針

| 制御 | 役割 |
|------|------|
| **`current_round`（セッション）** | 「今、どの STEP にいるか」だけを表す。**新しいメッセージの `step_round` を決める**のに使う。戻ったときにこの値を変える（例: STEP 1 に戻る → `current_round = 0`）。 |
| **`step_round`（メッセージ）** | そのメッセージが**どの STEP の会話に属するか**を表す。**既存メッセージは書き換えない**。戻る操作で他 STEP のメッセージを消したり、やり直しにしたりしない。 |

### 7.3 戻る・進むの挙動

- **STEP 2 → STEP 1 に戻る**
  - API で `current_round = 0` に更新。
  - 表示は STEP 1 の会話（`step_round = 1` のメッセージのみ）に切り替える。
  - このあと送るメッセージはすべて `step_round = 1` として保存 → **STEP 1 の「続き」**になる。
  - **STEP 2 のメッセージは一切触らない**（維持）。

- **再度 STEP 2 に進む**
  - 「このステップを終了」または AI の「次に進む」で `current_round = 1` に更新。
  - 表示は STEP 2 の会話（`step_round = 2` のメッセージのみ）に切り替える。
  - 以前の現状分析の会話がそのまま並び、**続き**として新しいメッセージが `step_round = 2` で追加される。

まとめ: **戻る = 表示と「これから書くメッセージの所属」を変えるだけ。他 STEP の会話はすべて維持し、続きになる。** フラグ制御は「`current_round` で新規メッセージの `step_round` を決める」「既存メッセージの `step_round` は更新しない」で実現する。

---

## 8. ステップ毎の会話を全部 Supabase に持てるか（重さの検討）

### 8.1 想定される量

- よく使うユーザー: 1 STEP あたり 30〜50 往復 → 60〜100 件/STEP。
- 5 STEP で **300〜500 件/セッション**。複数セッションで数千〜数万件になる可能性はある。

### 8.2 持てるか・重くないか

| 観点 | 結論 |
|------|------|
| **ストレージ** | 1 メッセージ数百〜2KB 程度としても、500 件で 1MB 未満。セッション数が増えても、まずは**全部 Supabase に持つ設計で問題ない**。 |
| **取得** | **表示は「今の STEP の会話だけ」**にするので、1 回の GET で返すのは例として 50〜100 件程度。ページネーションを入れればさらに軽くできる。 |
| **Dify** | STEP ごとに会話を分けて送る（または 1 STEP 1 `conversation_id`）にすれば、コンテキスト長も STEP 単位に抑えられる。 |

### 8.3 重くなったときの対策（将来）

- **STEP 単位のページネーション**: その STEP のメッセージを古い順で 20 件ずつなど。
- **要約の付与**: 一定件数以上になった STEP は、古い部分を要約して 1 メッセージにまとめ、レポート用には「要約 + 直近 N 件」を使う。
- **アーカイブ**: 完了したセッションの古いメッセージを別ストアに移す（検索・レポート用だけ残すなど）。

**結論**: 設計としては**ステップ毎の会話を全部 Supabase に持つ**形でよい。表示・API は STEP 単位に絞るので重くなりにくく、本当に負荷が増えた段階でページネーション・要約・アーカイブを検討すれば足りる。
